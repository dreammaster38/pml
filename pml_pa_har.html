<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>PML - Programming Assignment</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1>PML - Programming Assignment</h1>

<p>This Coursera course teaches us about Practical Machine Learning with R.
We get a good knowledge about various Machine Learning algorithms and useful R packages to made a Data Scientist&#39;s day more comfortable. This assessment should show what we have learned so far.</p>

<h1>Abstract</h1>

<hr/>

<p>Quantified Self movement is currently a new trend to improve personal or professional productivity in health and wellness. As discribed in Wikipedia, people have abelities to track physical activity, caloric intake, sleep quality, posture, and other factors involved in personal well-being.
To measure themselves various sensors will be used to collect specific data.</p>

<p>Our goal for this assignment will be to use data from accelerometers on the belt, forearm, arm, and dumbell of 6 participants. They were asked to perform barbell lifts correctly and incorrectly in 5 different ways. More information is available from the website here: <a href="http://groupware.les.inf.puc-rio.br/har">http://groupware.les.inf.puc-rio.br/har</a> (see the section on the Weight Lifting Exercise Dataset).</p>

<p>To accomplish this assignment we have to predict the manner in which they did the exercise. This is the &ldquo;classe&rdquo; variable in the training set.</p>

<h3>Important points are:</h3>

<ul>
<li>how we used cross validation</li>
<li>what is the expected out of sample error</li>
<li>why we made the choices you did</li>
<li>predict 20 given different test cases</li>
<li>a good accuracy</li>
</ul>

<h3>Minor points are:</h3>

<ul>
<li>performance</li>
<li>scalability</li>
</ul>

<p>I have devided my approach into different steps. I will subscribe each step as good as i can.</p>

<h2>Requirements</h2>

<p>Load all necessary libraries used for this project</p>

<pre><code class="r">library(caret)
</code></pre>

<pre><code>## Loading required package: lattice
## Loading required package: ggplot2
</code></pre>

<pre><code class="r">library(randomForest)
</code></pre>

<pre><code>## randomForest 4.6-7
## Type rfNews() to see new features/changes/bug fixes.
</code></pre>

<pre><code class="r">library(e1071)
library(doParallel)
</code></pre>

<pre><code>## Loading required package: foreach
## Loading required package: iterators
## Loading required package: parallel
</code></pre>

<h2>Step 1: Loading data</h2>

<p>Load the data sets and replace unuseful strings with NAs.</p>

<pre><code class="r">trainRawData &lt;- read.csv(&quot;data/pml-training.csv&quot;, na.strings=c(&quot;NA&quot;,&quot;&quot;, &quot;#DIV/0!&quot;))
testingRawData &lt;- read.csv(&quot;data/pml-testing.csv&quot;, na.strings=c(&quot;NA&quot;,&quot;&quot;, &quot;#DIV/0!&quot;))
</code></pre>

<h2>Step 2: Cleaning up the data</h2>

<p>Find columns with NAs set and remove them. This will remove columns which could be imputed too.
I made this as a comromise to speed things up.</p>

<pre><code class="r">set.seed(1972)
cleanedData &lt;- trainRawData[ ,colSums(is.na(trainRawData)) == 0]
testing &lt;- testingRawData[ ,colSums(is.na(trainRawData)) == 0]
</code></pre>

<p>Create a training and cross validation set as shown in the videos.
So we get 70% out of the data for training and 30% for crossvalidation</p>

<pre><code class="r">trainIndex &lt;- createDataPartition(y = cleanedData$classe, p=0.7, list=FALSE) # 3927 rows
training &lt;- cleanedData[trainIndex,]
cross &lt;- cleanedData[-trainIndex,]
</code></pre>

<p>Discard unuseful predictors because they are not numeric.</p>

<pre><code class="r">columnsToRemove &lt;- names(training) %in% c(&quot;raw_timestamp_part_1&quot;, &quot;raw_timestamp_part_2&quot;, &quot;cvtd_timestamp&quot;, &quot;X&quot;, &quot;user_name&quot;, &quot;new_window&quot;)
training &lt;- training[ , !columnsToRemove]
cross &lt;- cross[ , !columnsToRemove]
testing &lt;- testing[, !columnsToRemove]
</code></pre>

<p>The cleanup step gaves us 53 predictors to work with.</p>

<h3>Skewness</h3>

<p>Lets have a look at the skewness of the data. To find it out we use the skewness function of the &#39;e1071&#39; package.</p>

<pre><code class="r"># check data for skewness
classeName &lt;- names(training) %in% c(&quot;classe&quot;) 
testForSkewness &lt;- training[!classeName]
# apply the skewnes function to each numeric column of our training set
skewValues &lt;- apply(testForSkewness, 2, skewness)
# create a data frame for fancier printing
skewValuesDf &lt;- data.frame(skewValues)
print(skewValuesDf)
</code></pre>

<pre><code>##                      skewValues
## num_window            2.310e-02
## roll_belt            -2.050e-03
## pitch_belt           -9.953e-01
## yaw_belt              9.106e-01
## total_accel_belt      4.702e-02
## gyros_belt_x         -5.977e-01
## gyros_belt_y         -6.394e-02
## gyros_belt_z          2.113e-01
## accel_belt_x          9.646e-01
## accel_belt_y          1.767e-01
## accel_belt_z          6.569e-03
## magnet_belt_x         1.429e+00
## magnet_belt_y        -2.229e+00
## magnet_belt_z         2.631e-01
## roll_arm             -1.816e-01
## pitch_arm             1.956e-01
## yaw_arm              -8.960e-02
## total_accel_arm       7.324e-02
## gyros_arm_x          -2.953e-01
## gyros_arm_y           1.179e-01
## gyros_arm_z          -1.644e-01
## accel_arm_x           3.521e-01
## accel_arm_y           8.161e-02
## accel_arm_z          -8.565e-01
## magnet_arm_x         -1.513e-01
## magnet_arm_y         -4.653e-01
## magnet_arm_z         -1.146e+00
## roll_dumbbell        -7.509e-01
## pitch_dumbbell        5.359e-01
## yaw_dumbbell          2.237e-01
## total_accel_dumbbell  5.896e-01
## gyros_dumbbell_x     -1.089e+02
## gyros_dumbbell_y      3.587e+01
## gyros_dumbbell_z      1.148e+02
## accel_dumbbell_x     -4.547e-01
## accel_dumbbell_y      3.438e-01
## accel_dumbbell_z     -7.782e-02
## magnet_dumbbell_x     1.714e+00
## magnet_dumbbell_y    -1.862e+00
## magnet_dumbbell_z     8.682e-01
## roll_forearm         -4.631e-01
## pitch_forearm        -5.278e-01
## yaw_forearm          -2.664e-01
## total_accel_forearm  -5.693e-01
## gyros_forearm_x      -2.683e+00
## gyros_forearm_y       5.417e+01
## gyros_forearm_z       1.024e+02
## accel_forearm_x      -2.375e-01
## accel_forearm_y      -6.435e-01
## accel_forearm_z       4.371e-01
## magnet_forearm_x      6.327e-01
## magnet_forearm_y     -7.478e-01
## magnet_forearm_z     -1.216e+00
</code></pre>

<pre><code class="r"># plot a histogram of the skewness.
hist(skewValues, col=heat.colors(17), xlab=&quot;Skewness of all predictors&quot;, breaks=20)
</code></pre>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfgAAAH4CAMAAACR9g9NAAAAulBMVEX9/v0AAAAAADkAAGUAOTkAOWUAOY8AZo8AZrU5AAA5ADk5AGU5OQA5OWU5OY85ZmU5ZrU5j485j9plAABlADllAGVlOQBlOY9lZjllZmVlj49ltbVltf2POQCPOTmPOWWPZgCPjzmPj2WPtY+P27WP29qP2/21ZgC1Zjm1tWW124+1/rW1/v3ajzna24/a/rXa/tra/v39tWX924/9/rX9/tr9/v3/AAD/VQD/agD/1QD/6gD//2D//98m1l6QAAAAPnRSTlP///////////////////////////////////////////////////////////////////////8A/////////7GymF0AAAAJcEhZcwAACxIAAAsSAdLdfvwAAA8sSURBVHic7d17Y9r2FYfxyu48iDsvw3HXrSbZmhW2Ftpy07Zue/9va/p9dTEYbHRiKeZwnuePEmOh0PNBF2wIX+QUsi9e+w7Q6wR80IAPGvBBAz5owAcN+KABHzTggwZ80IAPGvBBAz5owAcN+KABHzTggwZ80IAPGvBBAz5owAcN+KABHzTgg+YQfn17OcvzzfhyVv6pbnr/gpWuhtnFZO8vOdhmnKW/aZldLY4vfLK5ht+5epq9BP7xrZ+znGcD3WLUZuFTzTW8/lRsq9nlrNgMs+QxLy4SSPH15Y+3V4vN+OKbYlteFlcXW/Qy+21x/axYqGYul9etyw24XJ3+knLTTkvcl4+zebHo+vbqp2G1QF6ttlxYV6aVlLdoVnWauYdf32YJ7ZcSfpq+KC4l+eUwwafv/lwutFhmdRVItfwDfLW6RVr1PPGVS4zy9MW0WPMyGxUPpkmhOthZ+AG+vkX93ded1lO5hK/t0sBXw2q0aWe9Gmr7u5ishtpABT+ob3Y5W2bpBtl9WiRd1yzf7Orr1RVL/zAcVV8n1NVwtL79U/FoKBaeVw+EerU78Fu3OFX0lHt4fZW230S3lHJhoj+sy139pL5Rgh9U++Xy2mb5Br5eXfFo+CpdVe0jLibr28Hqzcc3k2np+0t5ilGudgd+6xYZu/ouO3CMz6pt9il4LdPAPzwc9uHr1dVqDWM+vfxHcdbw7a1O7C4+lruDhwfgPnxzz04y//CpaUV3aFefJp/2zemqx/D7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" alt="plot of chunk unnamed-chunk-6"/> </p>

<p>As you can see we have left-skewness and also right-skewness in our data set. So we need some pre-processing prior to fit our model.
This step will be done directly in the preProcess step of caret&#39;s train function.</p>

<h2>Step 3 Model creation</h2>

<p>I&#39;ve trained a Random Forest with 10 K-Folds cross validation partitions in the train control parameter to accomplish this ask.
There was a pre processing step added to normalize the data because it&#39;s are skewed as showed above. I&#39;ve used center and scale to normalize it.</p>

<h3>Build a Random Forest (RF)</h3>

<h4>Advantages of RF:</h4>

<ul>
<li>very simple to use even with default settings</li>
<li>produces mostly results with good accuracy without special tuning parameters</li>
<li>robust</li>
<li>fast</li>
<li>can handle larger problems before slowing</li>
</ul>

<h4>Disadvantages of RF</h4>

<ul>
<li>difficult to interpret</li>
</ul>

<p>Further i&#39;ve used the doParallel package to speed things up little bit</p>

<pre><code class="r"># Create clusters for all available cores communicating over sockets
cl &lt;- makeCluster(detectCores() / 2)
registerDoParallel(cl)

# global settings used for for all models
#ctrl &lt;- trainControl(method=&#39;cv&#39;, number=10, savePred=T, classProb=T, verboseIter=T)
ctrl &lt;- trainControl(method=&#39;cv&#39;, number=10, allowParallel=TRUE)
</code></pre>

<p>Build a fitted Random Forest model with normalization, and 10-Fold cross vaidation</p>

<pre><code class="r">modFitRf &lt;- train(training$classe ~.,
                data = training,
                do.trace=100,
                method=&quot;rf&quot;,
                trControl=ctrl,
                preProcess=(method=c(&quot;center&quot;, &quot;scale&quot;)))
</code></pre>

<pre><code>## ntree      OOB      1      2      3      4      5
##   100:   0.26%  0.03%  0.53%  0.25%  0.40%  0.24%
##   200:   0.25%  0.05%  0.53%  0.25%  0.36%  0.20%
##   300:   0.25%  0.05%  0.45%  0.25%  0.36%  0.24%
##   400:   0.23%  0.05%  0.41%  0.25%  0.31%  0.24%
##   500:   0.24%  0.05%  0.38%  0.33%  0.31%  0.24%
</code></pre>

<h2>Results</h2>

<h3>Out of Sample accuracy, Random Forest</h3>

<p>Now let&#39;s take a look at our generated model and it&#39;s statistics which looks like as follows:</p>

<pre><code class="r">print(modFitRf)
</code></pre>

<pre><code>## Random Forest 
## 
## 13737 samples
##    53 predictors
##     5 classes: &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39; 
## 
## Pre-processing: centered, scaled 
## Resampling: Cross-Validated (10 fold) 
## 
## Summary of sample sizes: 12362, 12364, 12363, 12363, 12364, 12363, ... 
## 
## Resampling results across tuning parameters:
## 
##   mtry  Accuracy  Kappa  Accuracy SD  Kappa SD
##   2     1         1      0.003        0.003   
##   30    1         1      0.002        0.002   
##   50    1         1      0.002        0.003   
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final value used for the model was mtry = 27.
</code></pre>

<pre><code class="r">print(modFitRf$finalModel)
</code></pre>

<pre><code>## 
## Call:
##  randomForest(x = x, y = y, mtry = param$mtry, do.trace = 100) 
##                Type of random forest: classification
##                      Number of trees: 500
## No. of variables tried at each split: 27
## 
##         OOB estimate of  error rate: 0.24%
## Confusion matrix:
##      A    B    C    D    E class.error
## A 3904    1    0    0    1    0.000512
## B    7 2648    3    0    0    0.003762
## C    0    8 2388    0    0    0.003339
## D    0    0    6 2245    1    0.003108
## E    0    1    0    5 2519    0.002376
</code></pre>

<p>As you can see the OOB error is ~0.24%. This is a good result.</p>

<p>Predict against our cross validation set created in step 2 to find out the accuracy of our model.</p>

<pre><code class="r">predCrossRf &lt;- predict(modFitRf, cross)
print(confusionMatrix(predCrossRf, cross$classe))
</code></pre>

<pre><code>## Confusion Matrix and Statistics
## 
##           Reference
## Prediction    A    B    C    D    E
##          A 1674    1    0    0    0
##          B    0 1137    6    0    0
##          C    0    1 1020    5    0
##          D    0    0    0  959    0
##          E    0    0    0    0 1082
## 
## Overall Statistics
##                                         
##                Accuracy : 0.998         
##                  95% CI : (0.996, 0.999)
##     No Information Rate : 0.284         
##     P-Value [Acc &gt; NIR] : &lt;2e-16        
##                                         
##                   Kappa : 0.997         
##  Mcnemar&#39;s Test P-Value : NA            
## 
## Statistics by Class:
## 
##                      Class: A Class: B Class: C Class: D Class: E
## Sensitivity             1.000    0.998    0.994    0.995    1.000
## Specificity             1.000    0.999    0.999    1.000    1.000
## Pos Pred Value          0.999    0.995    0.994    1.000    1.000
## Neg Pred Value          1.000    1.000    0.999    0.999    1.000
## Prevalence              0.284    0.194    0.174    0.164    0.184
## Detection Rate          0.284    0.193    0.173    0.163    0.184
## Detection Prevalence    0.285    0.194    0.174    0.163    0.184
## Balanced Accuracy       1.000    0.998    0.996    0.997    1.000
</code></pre>

<p>The confusionMatrix shows us that we have an accuracy of 99.8% with our cross validation set, This is a pretty good result that fits our needs.</p>

<p>The accuracy is good enough to predict the test data set against our Random Forest model.</p>

<p>Print the overall agreement and Kappa:</p>

<pre><code class="r">accuracySummary &lt;- postResample(predCrossRf, cross$classe)
print(accuracySummary)
</code></pre>

<pre><code>## Accuracy    Kappa 
##   0.9978   0.9972
</code></pre>

<h2>Step 4: Submitted prediction results on the supplied test set</h2>

<p>This is my final result of the prediction that i submitted with my 53 predictors:</p>

<pre><code class="r">predRf &lt;- predict(modFitRf, testing)
print(predRf)
</code></pre>

<pre><code>##  [1] B A B A A E D B A A B C B A E E A B B B
## Levels: A B C D E
</code></pre>

<pre><code class="r"># stop all created cluster nodes
stopCluster(cl)
</code></pre>

<h2>FInal words</h2>

<p>I tried to train a Polymomial SVM too, so i can compare two models to each other. Unfortunately it runs a couple of hours and it was not possible for me to build this final document with both models trained via knitr again and again.
It tooks me many, many time to accomplish this task nevertheless i had a lot of fun to play with ML technology.</p>

<h2>References</h2>

<p>[1]: <a href="http://groupware.les.inf.puc-rio.br/har">http://groupware.les.inf.puc-rio.br/har</a>, Data sets for Human Activity Recognition</p>

<p>[2]: Albert A. Montillo, Ph.D., Guest lecture: Statistical Foundations of Data Analysis
Temple University 4-2-2009, <a href="http://www.dabi.temple.edu/%7Ehbling/8590.002/Montillo_RandomForests_4-2-2009.pdf">http://www.dabi.temple.edu/~hbling/8590.002/Montillo_RandomForests_4-2-2009.pdf</a></p>

<p>[3]: Velloso, E.; Bulling, A.; Gellersen, H.; Ugulino, W.; Fuks, H. Qualitative Activity Recognition of Weight Lifting Exercises. Proceedings of 4th International Conference in Cooperation with SIGCHI (Augmented Human &#39;13) . Stuttgart, Germany: ACM SIGCHI, 2013.</p>

<p>[4]: Kuhn, M.; Johnson, K. Applied Predictive Modeing, Springer 2013</p>

</body>

</html>

